const char *cl_source_stencil2d =
"\n"
"// define types based on compiler \"command line\"\n"
"#if defined(SINGLE_PRECISION)\n"
"#define VALTYPE float\n"
"#elif defined(K_DOUBLE_PRECISION)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64: enable\n"
"#define VALTYPE double\n"
"#elif defined(AMD_DOUBLE_PRECISION)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64: enable\n"
"#define VALTYPE double\n"
"#else\n"
"#error No precision defined.\n"
"#endif\n"
"\n"
"\n"
"inline\n"
"int\n"
"ToGlobalRow( int gidRow, int lszRow, int lidRow )\n"
"{\n"
"    // assumes coordinates and dimensions are logical (without halo)\n"
"    // returns logical global row (without halo)\n"
"    return gidRow*lszRow + lidRow;\n"
"}\n"
"\n"
"inline\n"
"int\n"
"ToGlobalCol( int gidCol, int lszCol, int lidCol )\n"
"{\n"
"    // assumes coordinates and dimensions are logical (without halo)\n"
"    // returns logical global column (without halo)\n"
"    return gidCol*lszCol + lidCol;\n"
"}\n"
"\n"
"\n"
"inline\n"
"int\n"
"ToFlatHaloedIdx( int row, int col, int rowPitch )\n"
"{\n"
"    // assumes input coordinates and dimensions are logical (without halo)\n"
"    // and a halo of width 1\n"
"    return (row + 1)*(rowPitch + 2) + (col + 1);\n"
"}\n"
"\n"
"\n"
"inline\n"
"int\n"
"ToFlatIdx( int row, int col, int pitch )\n"
"{\n"
"    return row * pitch + col;\n"
"}\n"
"\n"
"\n"
"__kernel\n"
"void\n"
"CopyRect( __global VALTYPE* dest,\n"
"            int doffset,\n"
"            int dpitch,\n"
"            __global VALTYPE* src,\n"
"            int soffset,\n"
"            int spitch,\n"
"            int width,\n"
"            int height )\n"
"{\n"
"    int gid = get_group_id(0);\n"
"    int lid = get_local_id(0);\n"
"    int gsz = get_global_size(0);\n"
"    int lsz = get_local_size(0);\n"
"    int grow = gid * lsz + lid;\n"
"\n"
"    if( grow < height )\n"
"    {\n"
"        for( int c = 0; c < width; c++ )\n"
"        {\n"
"            (dest + doffset)[ToFlatIdx(grow,c,dpitch)] = (src + soffset)[ToFlatIdx(grow,c,spitch)];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"__kernel\n"
"void\n"
"StencilKernel( __global VALTYPE* data,\n"
"                __global VALTYPE* newData,\n"
"                const int alignment,\n"
"                VALTYPE wCenter,\n"
"                VALTYPE wCardinal,\n"
"                VALTYPE wDiagonal,\n"
"                __local VALTYPE* sh )\n"
"{\n"
"    // determine our location in the OpenCL coordinate system\n"
"    // To match with the row-major ordering used to store the 2D\n"
"    // array in both the host and on the device, we use:\n"
"    //   dimension 0 == rows,\n"
"    //   dimension 1 == columns\n"
"    int gidRow = get_group_id(0);\n"
"    int gidCol = get_group_id(1);\n"
"    int gszRow = get_num_groups(0);\n"
"    int gszCol = get_num_groups(1);\n"
"    int lidRow = get_local_id(0);\n"
"    int lidCol = get_local_id(1);\n"
"    int lszRow = LROWS;\n"
"    int lszCol = get_local_size(1);\n"
"\n"
"    // determine our logical global data coordinates (without halo)\n"
"    int gRow = ToGlobalRow( gidRow, lszRow, lidRow );\n"
"    int gCol = ToGlobalCol( gidCol, lszCol, lidCol );\n"
"\n"
"    // determine pitch of rows (without halo)\n"
"    int nCols = gszCol * lszCol + 2;     // num columns including halo\n"
"    int nPaddedCols = nCols + (((nCols % alignment) == 0) ? 0 : (alignment - (nCols % alignment)));\n"
"    int gRowWidth = nPaddedCols - 2;    // remove the halo\n"
"\n"
"    // Copy my global data item to a shared local buffer.\n"
"    // That local buffer is passed to us as a parameter.\n"
"    // We assume it is large enough to hold all the data computed by\n"
"    // our block, plus a halo of width 1.\n"
"    int lRowWidth = lszCol;          // logical, not haloed\n"
"    for( int i = 0; i < (lszRow + 2); i++ )\n"
"    {\n"
"        int lidx = ToFlatHaloedIdx( lidRow - 1 + i, lidCol, lRowWidth );\n"
"        int gidx = ToFlatHaloedIdx( gRow - 1 + i, gCol, gRowWidth );\n"
"        sh[lidx] = data[gidx];\n"
"    }\n"
"\n"
"    // Copy the \"left\" and \"right\" halo rows into our local memory buffer.\n"
"    // Only two threads are involved (first column and last column).\n"
"    if( lidCol == 0 )\n"
"    {\n"
"        for( int i = 0; i < (lszRow + 2); i++ )\n"
"        {\n"
"            int lidx = ToFlatHaloedIdx(lidRow - 1 + i, lidCol - 1, lRowWidth );\n"
"            int gidx = ToFlatHaloedIdx(gRow - 1 + i, gCol - 1, gRowWidth );\n"
"            sh[lidx] = data[gidx];\n"
"        }\n"
"    }\n"
"    else if( lidCol == (lszCol - 1) )\n"
"    {\n"
"        for( int i = 0; i < (lszRow + 2); i++ )\n"
"        {\n"
"            int lidx = ToFlatHaloedIdx(lidRow - 1 + i, lidCol + 1, lRowWidth );\n"
"            int gidx = ToFlatHaloedIdx(gRow - 1 + i, gCol + 1, gRowWidth );\n"
"            sh[lidx] = data[gidx];\n"
"        }\n"
"    }\n"
"\n"
"    // let all those loads finish\n"
"    barrier( CLK_LOCAL_MEM_FENCE );\n"
"\n"
"    // do my part of the smoothing operation\n"
"    for( int i = 0; i < lszRow; i++ )\n"
"    {\n"
"        int cidx  = ToFlatHaloedIdx( lidRow     + i, lidCol    , lRowWidth );\n"
"        int nidx  = ToFlatHaloedIdx( lidRow - 1 + i, lidCol    , lRowWidth );\n"
"        int sidx  = ToFlatHaloedIdx( lidRow + 1 + i, lidCol    , lRowWidth );\n"
"        int eidx  = ToFlatHaloedIdx( lidRow     + i, lidCol + 1, lRowWidth );\n"
"        int widx  = ToFlatHaloedIdx( lidRow     + i, lidCol - 1, lRowWidth );\n"
"        int neidx = ToFlatHaloedIdx( lidRow - 1 + i, lidCol + 1, lRowWidth );\n"
"        int seidx = ToFlatHaloedIdx( lidRow + 1 + i, lidCol + 1, lRowWidth );\n"
"        int nwidx = ToFlatHaloedIdx( lidRow - 1 + i, lidCol - 1, lRowWidth );\n"
"        int swidx = ToFlatHaloedIdx( lidRow + 1 + i, lidCol - 1, lRowWidth );\n"
"\n"
"        VALTYPE centerValue = sh[cidx];\n"
"        VALTYPE cardinalValueSum = sh[nidx] + sh[sidx] + sh[eidx] + sh[widx];\n"
"        VALTYPE diagonalValueSum = sh[neidx] + sh[seidx] + sh[nwidx] + sh[swidx];\n"
"\n"
"        newData[ToFlatHaloedIdx(gRow + i, gCol, gRowWidth)] = wCenter * centerValue +\n"
"                wCardinal * cardinalValueSum +\n"
"                wDiagonal * diagonalValueSum;\n"
"    }\n"
"}\n"
"\n"
;
